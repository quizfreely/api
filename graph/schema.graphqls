type Query {
    authed: Boolean
    authedUser: AuthedUser
    studyset(id: ID!): Studyset
    user(id: ID!): User
    featuredStudysets(limit: Int, offset: Int): [Studyset]
    recentStudysets(limit: Int, offset: Int): [Studyset]
    searchStudysets(q: String!, limit: Int, offset: Int): [Studyset]
    myStudysets(limit: Int, offset: Int): [Studyset]
}
type Mutation {
    createStudyset(studyset: StudysetInput!, terms: [NewTermInput]): Studyset
    updateStudyset(id: ID!, studyset: StudysetInput, terms: [TermInput], newTerms: [NewTermInput], deleteTerms: [ID]): Studyset
    deleteStudyset(id: ID!): ID
    updateUser(displayName: String): AuthedUser
    updateTermProgress(termId: ID!, progress: TermProgressInput!): TermProgress
    recordConfusedTerms(confusedTerms: [TermConfusionPairInput]): Boolean
    recordPracticeTest(input: PracticeTestInput): PracticeTest
}
type User {
    id: ID
    username: String
    displayName: String
}
type AuthedUser {
    id: ID
    username: String
    displayName: String
    authType: AuthType
    oauthGoogleEmail: String
}
enum AuthType {
    USERNAME_PASSWORD
    OAUTH_GOOGLE
}
type Studyset {
    id: ID
    title: String
    private: Boolean
    updatedAt: String
    user: User
    terms: [Term]
    termsCount: Int
    practiceTests: [PracticeTest]
}
type Term {
    id: ID
    term: String
    def: String
    sortOrder: Int
    progress: TermProgress
    topConfusionPairs: [TermConfusionPair]
    topReverseConfusionPairs: [TermConfusionPair]
    createdAt: String
    updatedAt: String
}
input StudysetInput {
    title: String!
    private: Boolean!
}
input NewTermInput {
    term: String
    def: String
    sortOrder: Int!
}
input TermInput {
    id: ID!
    term: String
    def: String
    sortOrder: Int
}
type TermProgress {
    id: ID
    termFirstReviewedAt: String
    termLastReviewedAt: String
    termReviewCount: Int
    defFirstReviewedAt: String
    defLastReviewedAt: String
    defReviewCount: Int
    termCorrectCount: Int
    termIncorrectCount: Int
    defCorrectCount: Int
    defIncorrectCount: Int
    termLeitnerSystemBox: Int
    defLeitnerSystemBox: Int
}
input TermProgressInput {
    termReviewedAt: String
    defReviewedAt: String
    termLeitnerSystemBox: Int
    defLeitnerSystemBox: Int
    termCorrectIncrease: Int
    termIncorrectIncrease: Int
    defCorrectIncrease: Int
    defIncorrectIncrease: Int
}
enum AnswerWith {
    TERM
    DEF
}
type TermConfusionPair {
    id: ID
    confusedTerm: Term
    answeredWith: AnswerWith
    confusedCount: Int
    lastConfusedAt: String
}
input TermConfusionPairInput {
    termId: ID
    confusedTermId: ID
    answeredWith: AnswerWith
    confusedCountIncrease: Int
    confusedAt: String
}
type PracticeTest {
    id: ID
    timestamp: String
    questionsCorrect: Int
    questionsTotal: Int
    questions: [Question]
}
enum QuestionType {
    MCQ
    TRUE_FALSE
    MATCH
    FRQ
}
type Question {
    questionType: QuestionType
    mcq: MCQ
    trueFalseQuestion: TrueFalseQuestion
    matchQuestionInput: MatchQuestion
    frq: FRQ
}
type MCQ {
    term: TermInput
    answerWith: AnswerWith
    correct: Boolean
    answeredTerm: TermInput
    distractors: [TermInput]
}
type TrueFalseQuestion {
    term: TermInput
    answerWith: AnswerWith
    correct: Boolean
    answeredBool: Boolean
    distractor: TermInput
}
type MatchQuestion {
    term: TermInput
    answerWith: AnswerWith
    correct: Boolean
    answeredTerm: TermInput
    group: Int
}
type FRQ {
    term: TermInput
    answerWith: AnswerWith
    correct: Boolean
    answeredString: String
}
input PracticeTestInput {
    timestamp: String
    studysetId: ID
    questionsCorrect: Int
    questionsTotal: Int
    questions: [QuestionInput]
}
input QuestionInput {
    questionType: QuestionType
    mcqInput: MCQInput
    trueFalseQuestionInput: TrueFalseQuestionInput
    matchQuestionInput: MatchQuestionInput
    frqInput: FRQInput
}
input MCQInput {
    term: TermInput
    answerWith: AnswerWith
    correct: Boolean
    answeredTerm: TermInput
    distractors: [TermInput]
}
input TrueFalseQuestionInput {
    term: TermInput
    answerWith: AnswerWith
    correct: Boolean
    answeredBool: Boolean
    distractor: TermInput
}
input MatchQuestionInput {
    term: TermInput
    answerWith: AnswerWith
    correct: Boolean
    answeredTerm: TermInput
    group: Int
}
input FRQInput {
    term: TermInput
    answerWith: AnswerWith
    correct: Boolean
    answeredString: String
}
