package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"errors"
	"fmt"
	"quizfreely/api/auth"
	"quizfreely/api/graph/model"
	"strings"
	"time"

	"github.com/georgysavva/scany/v2/pgxscan"
	pgx "github.com/jackc/pgx/v5"
)

// CreateStudyset is the resolver for the createStudyset field.
func (r *mutationResolver) CreateStudyset(ctx context.Context, studyset model.StudysetInput) (*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	title := "Untitled Studyset"
	if len(studyset.Title) > 0 && len(studyset.Title) < 200 && validTitleRegex.MatchString(studyset.Title) {
		title = studyset.Title
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	termsCount := 0
	if studyset.Data != nil && studyset.Data.Terms != nil {
		termsCount = len(studyset.Data.Terms)
	}

	sql := `
		INSERT INTO public.studysets (user_id, title, private, data, terms_count)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id, user_id, title, private, data, terms_count,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
	`
	var newStudyset model.Studyset
	err = pgxscan.Get(ctx, tx, &newStudyset, sql, authedUser.ID, title, studyset.Private, studyset.Data, termsCount)
	if err != nil {
		return nil, fmt.Errorf("failed to create studyset: %w", err)
	}

	// The user_display_name is not returned from the INSERT...RETURNING statement.
	// We can set it from the authenticated user in the context.
	newStudyset.UserDisplayName = authedUser.DisplayName

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &newStudyset, nil
}

// UpdateStudyset is the resolver for the updateStudyset field.
func (r *mutationResolver) UpdateStudyset(ctx context.Context, id string, studyset *model.StudysetInput) (*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if studyset == nil {
		// Per schema, studyset input is optional. If it's not provided, we don't
		// have anything to update. We'll fetch the existing studyset and return it.
		// We can use the Studyset query resolver for this.
		return r.Query().Studyset(ctx, id)
	}

	title := "Untitled Studyset"
	if len(studyset.Title) > 0 && len(studyset.Title) < 200 && validTitleRegex.MatchString(studyset.Title) {
		title = studyset.Title
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	termsCount := 0
	if studyset.Data != nil && studyset.Data.Terms != nil {
		termsCount = len(studyset.Data.Terms)
	}

	sql := `
		UPDATE public.studysets
		SET title = $1, private = $2, data = $3, terms_count = $4
		WHERE id = $5 AND user_id = $6
		RETURNING id, user_id, title, private, data, terms_count,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
	`
	var updatedStudyset model.Studyset
	err = pgxscan.Get(ctx, tx, &updatedStudyset, sql, title, studyset.Private, studyset.Data, termsCount, id, authedUser.ID)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("studyset not found")
		}
		return nil, fmt.Errorf("failed to update studyset: %w", err)
	}

	// The user_display_name is not returned from the UPDATE...RETURNING statement.
	// We can set it from the authenticated user in the context. The query now
	// ensures that only the owner can update the studyset.
	updatedStudyset.UserDisplayName = authedUser.DisplayName

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &updatedStudyset, nil
}

// DeleteStudyset is the resolver for the deleteStudyset field.
func (r *mutationResolver) DeleteStudyset(ctx context.Context, id string) (*string, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var deletedID string
	err = tx.QueryRow(ctx, "DELETE FROM public.studysets WHERE id = $1 AND user_id = $2 RETURNING id", id, authedUser.ID).Scan(&deletedID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, fmt.Errorf("studyset not found")
		}
		return nil, fmt.Errorf("failed to delete studyset: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &deletedID, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, displayName *string) (*model.AuthedUser, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if displayName != nil {
		trimmedDisplayName := strings.TrimSpace(*displayName)
		if len(trimmedDisplayName) < 1 || len(trimmedDisplayName) > 32 {
			return nil, fmt.Errorf("display name must be between 1 and 32 characters")
		}
		if *displayName != trimmedDisplayName {
			return nil, fmt.Errorf("display name must not have leading or trailing whitespace")
		}
	} else {
		return authedUser, nil
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var updatedUser model.AuthedUser
	err = pgxscan.Get(ctx, tx, &updatedUser,
		`UPDATE auth.users SET display_name = $1 WHERE id = $2 RETURNING id, display_name`,
		*displayName, authedUser.ID)

	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &updatedUser, nil
}

// UpdateStudysetProgress is the resolver for the updateStudysetProgress field.
func (r *mutationResolver) UpdateStudysetProgress(ctx context.Context, studysetID string, progressChanges []*model.StudysetProgressTermInput) (*model.StudysetProgress, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Ensure all progress changes have valid numbers (convert nil to 0)
	for _, change := range progressChanges {
		if change.TermCorrect == nil { var zero int32 = 0; change.TermCorrect = &zero }
		if change.TermIncorrect == nil { var zero int32 = 0; change.TermIncorrect = &zero }
		if change.DefCorrect == nil { var zero int32 = 0; change.DefCorrect = &zero }
		if change.DefIncorrect == nil { var zero int32 = 0; change.DefIncorrect = &zero }
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// Check if progress already exists for this user/studyset
	var existingProgress struct {
		ID        string `db:"id"`
		Terms     []*model.StudysetProgressTerm `db:"terms"`
	}
	sql := `
		SELECT id, terms 
		FROM public.studyset_progress 
		WHERE user_id = $1 AND studyset_id = $2
	`
	err = pgxscan.Get(ctx, tx, &existingProgress, sql, authedUser.ID, studysetID)
	
	var result *model.StudysetProgress
	
	if err == nil {
		// Update existing progress
		updatedProgress := existingProgress.Terms
		existingProgressMap := make(map[[2]string]int)
		for i, term := range updatedProgress {
			existingProgressMap[[2]string{term.Term, term.Def}] = i
		}
		
		rnDateTimeString := time.Now().UTC().Format(time.RFC3339)
		for _, change := range progressChanges {
			key := [2]string{change.Term, change.Def}
			if idx, exists := existingProgressMap[key]; exists {
				// Update existing term stats
				updatedProgress[idx].TermCorrect += *change.TermCorrect
				updatedProgress[idx].TermIncorrect += *change.TermIncorrect
				updatedProgress[idx].DefCorrect += *change.DefCorrect
				updatedProgress[idx].DefIncorrect += *change.DefIncorrect
				updatedProgress[idx].LastReviewedAt = rnDateTimeString
				updatedProgress[idx].ReviewSessionsCount++
			} else {
				// Add new term
				updatedProgress = append(updatedProgress, &model.StudysetProgressTerm{
					Term: change.Term,
					Def: change.Def,
					TermCorrect: *change.TermCorrect,
					TermIncorrect: *change.TermIncorrect,
					DefCorrect: *change.DefCorrect,
					DefIncorrect: *change.DefIncorrect,
					FirstReviewedAt: rnDateTimeString,
					LastReviewedAt: rnDateTimeString,
					ReviewSessionsCount: 1,
				})
			}
		}
		
		// Update record in database
		var updatedRecord struct {
			ID          string  `db:"id"`
			StudysetID  string  `db:"studyset_id"`
			UserID      string  `db:"user_id"`
			UpdatedAt   string  `db:"updated_at"`
		}
		sql = `
			UPDATE public.studyset_progress 
			SET terms = $2, updated_at = clock_timestamp() 
			WHERE id = $1 
			RETURNING id, studyset_id, user_id, to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		`
		err = pgxscan.Get(ctx, tx, &updatedRecord, sql, existingProgress.ID, updatedProgress)
		if err != nil {
			return nil, fmt.Errorf("failed to update studyset progress: %w", err)
		}
		
		updatedAtPtr := &updatedRecord.UpdatedAt
		result = &model.StudysetProgress{
			ID:          updatedRecord.ID,
			StudysetID:  updatedRecord.StudysetID,
			UserID:      updatedRecord.UserID,
			Terms:       updatedProgress,
			UpdatedAt:   updatedAtPtr,
		}
	} else if pgxscan.NotFound(err) {
		// Create new progress record
		rnDateTimeString := time.Now().UTC().Format(time.RFC3339)
		progress := make([]*model.StudysetProgressTerm, len(progressChanges))
		for i, change := range progressChanges {
			progress[i] = &model.StudysetProgressTerm{
				Term: change.Term,
				Def: change.Def,
				TermCorrect: *change.TermCorrect,
				TermIncorrect: *change.TermIncorrect,
				DefCorrect: *change.DefCorrect,
				DefIncorrect: *change.DefIncorrect,
				FirstReviewedAt: rnDateTimeString,
				LastReviewedAt: rnDateTimeString,
				ReviewSessionsCount: 1,
			}
		}
		
		// Insert new record
		var newRecord struct {
			ID          string  `db:"id"`
			StudysetID  string  `db:"studyset_id"`
			UserID      string  `db:"user_id"`
			UpdatedAt   string  `db:"updated_at"`
		}
		sql = `
			INSERT INTO public.studyset_progress (studyset_id, user_id, terms, updated_at) 
			VALUES ($1, $2, $3, clock_timestamp()) 
			RETURNING id, studyset_id, user_id, to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		`
		err = pgxscan.Get(ctx, tx, &newRecord, sql, studysetID, authedUser.ID, progress)
		if err != nil {
			return nil, fmt.Errorf("failed to create studyset progress: %w", err)
		}
		
		updatedAtPtr := &newRecord.UpdatedAt
		result = &model.StudysetProgress{
			ID:          newRecord.ID,
			StudysetID:  newRecord.StudysetID,
			UserID:      newRecord.UserID,
			Terms:       progress,
			UpdatedAt:   updatedAtPtr,
		}
	} else {
		return nil, fmt.Errorf("failed to check existing progress: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return result, nil
}

// DeleteStudysetProgress is the resolver for the deleteStudysetProgress field.
func (r *mutationResolver) DeleteStudysetProgress(ctx context.Context, studysetID string) (*string, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var deletedID string
	err = tx.QueryRow(ctx, "DELETE FROM public.studyset_progress WHERE studyset_id = $1 RETURNING studyset_id", studysetID).Scan(&deletedID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return &studysetID, nil
		}
		return nil, fmt.Errorf("failed to delete studyset progress: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &deletedID, nil
}

// UpdateStudysetSettings is the resolver for the updateStudysetSettings field.
func (r *mutationResolver) UpdateStudysetSettings(ctx context.Context, studysetID string, changedSettings model.StudysetSettingsInput) (*model.StudysetSettings, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	sql := `
		INSERT INTO public.studyset_settings (studyset_id, user_id, good_acc, bad_acc, learning_min_sessions_count)
		VALUES ($1, $2, $3, $4, $5)
		ON CONFLICT (studyset_id, user_id) DO UPDATE SET
			good_acc = $3,
			bad_acc = $4,
			learning_min_sessions_count = $5
		RETURNING studyset_id, user_id, good_acc, bad_acc, learning_min_sessions_count, to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
	`
	var updatedSettings model.StudysetSettings
	err = pgxscan.Get(ctx, tx, &updatedSettings, sql, studysetID, authedUser.ID, changedSettings.GoodAcc, changedSettings.BadAcc, changedSettings.LearningMinSessionsCount)
	if err != nil {
		return nil, fmt.Errorf("failed to update studyset settings: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &updatedSettings, nil
}

// Authed is the resolver for the authed field.
func (r *queryResolver) Authed(ctx context.Context) (*bool, error) {
	authed := auth.AuthedUserContext(ctx) != nil
	return &authed, nil
}

// AuthedUser is the resolver for the authedUser field.
func (r *queryResolver) AuthedUser(ctx context.Context) (*model.AuthedUser, error) {
	return auth.AuthedUserContext(ctx), nil
}

// Studyset is the resolver for the studyset field.
func (r *queryResolver) Studyset(ctx context.Context, id string) (*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)

	// A transaction is used here to ensure that the RLS settings are applied
	// for the duration of the query.
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var studyset model.Studyset
	if authedUser != nil {
		sql := `
			SELECT id, user_id, title, private, data, terms_count,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at,
				(SELECT display_name FROM auth.users WHERE id = studysets.user_id) AS user_display_name
			FROM public.studysets
			WHERE id = $1 AND (private = false OR (private = true AND user_id = $2))`
		err = pgxscan.Get(ctx, tx, &studyset, sql, id, authedUser.ID)
	} else {
		sql := `
			SELECT id, user_id, title, private, data, terms_count,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at,
				(SELECT display_name FROM auth.users WHERE id = studysets.user_id) AS user_display_name
			FROM public.studysets
			WHERE id = $1 AND private = false`
		err = pgxscan.Get(ctx, tx, &studyset, sql, id)
	}
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("studyset not found")
		}
		return nil, fmt.Errorf("failed to fetch studyset: %w", err)
	}

	return &studyset, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	var user model.User
	sql := `
		SELECT
			id,
			username,
			display_name,
		FROM auth.users
		WHERE id = $1
	`
	err := pgxscan.Get(ctx, r.DB, &user, sql, id)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}
	return &user, nil
}

// FeaturedStudysets is the resolver for the featuredStudysets field.
func (r *queryResolver) FeaturedStudysets(ctx context.Context, limit *int32, offset *int32) ([]*model.Studyset, error) {
	l := 20
	if limit != nil && *limit > 0 && *limit < 20 {
		l = int(*limit)
	}

	o := 0
	if offset != nil && *offset > 0 {
		o = int(*offset)
	}

	var studysets []*model.Studyset
	sql := `
		SELECT
			id,
			user_id,
			title,
			private,
			data,
			terms_count,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at,
			(SELECT display_name FROM auth.users WHERE id = studysets.user_id) AS user_display_name
		FROM public.studysets
		WHERE private = false
			AND featured = true
		ORDER BY terms_count DESC
		LIMIT $1 OFFSET $2
	`
	err := pgxscan.Select(ctx, r.DB, &studysets, sql, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch featured studysets: %w", err)
	}

	return studysets, nil
}

// RecentStudysets is the resolver for the recentStudysets field.
func (r *queryResolver) RecentStudysets(ctx context.Context, limit *int32, offset *int32) ([]*model.Studyset, error) {
	l := 20
	if limit != nil && *limit > 0 && *limit < 20 {
		l = int(*limit)
	}

	o := 0
	if offset != nil && *offset > 0 {
		o = int(*offset)
	}

	var studysets []*model.Studyset
	sql := `
		SELECT
			id,
			user_id,
			title,
			private,
			data,
			terms_count,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at,
			(SELECT display_name FROM auth.users WHERE id = studysets.user_id) AS user_display_name
		FROM public.studysets
		WHERE private = false
		ORDER BY updated_at DESC
		LIMIT $1 OFFSET $2
	`
	err := pgxscan.Select(ctx, r.DB, &studysets, sql, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch recent studysets: %w", err)
	}

	return studysets, nil
}

// SearchStudysets is the resolver for the searchStudysets field.
func (r *queryResolver) SearchStudysets(ctx context.Context, q string, limit *int32, offset *int32) ([]*model.Studyset, error) {
	l := 20
	if limit != nil && *limit > 0 && *limit < 20 {
		l = int(*limit)
	}

	o := 0
	if offset != nil && *offset > 0 {
		o = int(*offset)
	}

	var studysets []*model.Studyset
	sql := `
		SELECT
			id,
			user_id,
			title,
			private,
			data,
			terms_count,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at,
			(SELECT display_name FROM auth.users WHERE id = studysets.user_id) AS user_display_name
		FROM public.studysets
		WHERE tsvector_title @@ websearch_to_tsquery('english', $1) AND private = false
		ORDER BY ts_rank(tsvector_title, websearch_to_tsquery('english', $1)) DESC
		LIMIT $2 OFFSET $3
	`
	err := pgxscan.Select(ctx, r.DB, &studysets, sql, q, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to search studysets: %w", err)
	}

	return studysets, nil
}

// MyStudysets is the resolver for the myStudysets field.
func (r *queryResolver) MyStudysets(ctx context.Context, limit *int32, offset *int32) ([]*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	l := 20
	if limit != nil && *limit > 0 && *limit < 20 {
		l = int(*limit)
	}

	o := 0
	if offset != nil && *offset > 0 {
		o = int(*offset)
	}

	var studysets []*model.Studyset
	sql := `
		SELECT
			id,
			user_id,
			title,
			private,
			data,
			terms_count,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at,
			(SELECT display_name FROM auth.users WHERE id = studysets.user_id) AS user_display_name
		FROM public.studysets
		WHERE user_id = $1
		ORDER BY updated_at DESC
		LIMIT $2 OFFSET $3
	`
	err := pgxscan.Select(ctx, r.DB, &studysets, sql, authedUser.ID, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch my studysets: %w", err)
	}

	return studysets, nil
}

// StudysetProgress is the resolver for the studysetProgress field.
func (r *queryResolver) StudysetProgress(ctx context.Context, studysetID string) (*model.StudysetProgress, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, nil // Return nil, nil if the user is not authenticated
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var studysetProgress model.StudysetProgress
	sql := `
		SELECT
			id,
			studyset_id,
			user_id,
			terms,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		FROM public.studyset_progress
		WHERE studyset_id = $1 AND user_id = $2
	`
	err = pgxscan.Get(ctx, tx, &studysetProgress, sql, studysetID, authedUser.ID)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, nil // Return nil, nil if no progress is found
		}
		return nil, fmt.Errorf("failed to fetch studyset progress: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &studysetProgress, nil
}

// StudysetSettings is the resolver for the studysetSettings field.
func (r *queryResolver) StudysetSettings(ctx context.Context, studysetID string) (*model.StudysetSettings, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, nil
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var studysetSettings model.StudysetSettings
	sql := `
		SELECT
			studyset_id,
			user_id,
			shuffle,
			study_starred,
			front_side_first,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		FROM public.studyset_settings
		WHERE studyset_id = $1 AND user_id = $2
	`
	err = pgxscan.Get(ctx, tx, &studysetSettings, sql, studysetID, authedUser.ID)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, nil // Return nil, nil if no settings are found
		}
		return nil, fmt.Errorf("failed to fetch studyset settings: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &studysetSettings, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
