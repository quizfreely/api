package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"errors"
	"fmt"
	"quizfreely/api/auth"
	"quizfreely/api/graph/loader"
	"quizfreely/api/graph/model"
	"strings"
	"time"

	"github.com/georgysavva/scany/v2/pgxscan"
	pgx "github.com/jackc/pgx/v5"
)

// Studysets is the resolver for the studysets field.
func (r *folderResolver) Studysets(ctx context.Context, obj *model.Folder) ([]*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if obj == nil || obj.ID == nil {
		return nil, nil
	}

	var studysets []*model.Studyset
	sql := `
		SELECT
			s.id,
			s.user_id,
			s.title,
			s.private,
			s.subject_id,
			to_char(s.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
			to_char(s.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		FROM folder_studysets f
		JOIN studysets s ON f.studyset_id = s.id
		WHERE f.user_id = $1
			AND f.folder_id = $2
			AND (s.private = false OR s.user_id = $1)
		ORDER BY f.timestamp DESC
	`
	err := pgxscan.Select(ctx, r.DB, &studysets, sql, authedUser.ID, *obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch folder's studysets: %w", err)
	}

	return studysets, nil
}

// CreateStudyset is the resolver for the createStudyset field.
func (r *mutationResolver) CreateStudyset(ctx context.Context, studyset model.StudysetInput, folderID *string) (*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	title := "Untitled Studyset"
	if len(studyset.Title) > 0 && len(studyset.Title) < 200 && validTitleRegex.MatchString(studyset.Title) {
		title = studyset.Title
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	sql := `
		INSERT INTO public.studysets (user_id, title, private, subject_id)
		VALUES ($1, $2, $3, $4)
		RETURNING id, user_id, title, private,
			to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
	`
	var newStudyset model.Studyset
	err = pgxscan.Get(ctx, tx, &newStudyset, sql, authedUser.ID, title, studyset.Private, studyset.SubjectID)
	if err != nil {
		return nil, fmt.Errorf("failed to create studyset: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	if folderID != nil {
		r.SetStudysetFolder(ctx, *newStudyset.ID, *folderID)
	}

	return &newStudyset, nil
}

// UpdateStudyset is the resolver for the updateStudyset field.
func (r *mutationResolver) UpdateStudyset(ctx context.Context, id string, studyset *model.StudysetInput) (*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if studyset == nil {
		return r.Query().Studyset(ctx, id)
	}

	// if the user doesn't own the studyset, the query affects 0 rows, and we return a "not found" error
	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var updatedStudyset model.Studyset
	title := "Untitled Studyset"
	if len(studyset.Title) > 0 && len(studyset.Title) < 200 && validTitleRegex.MatchString(studyset.Title) {
		title = studyset.Title
	}

	sql := `
		UPDATE public.studysets
		SET title = $1, private = $2, subject_id = $3, updated_at = now()
		WHERE id = $4 AND (user_id = $5 OR COALESCE($6, false) = true)
		RETURNING id, user_id, title, private, subject_id,
			to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
	`
	err = pgxscan.Get(ctx, tx, &updatedStudyset, sql, title, studyset.Private, studyset.SubjectID, id, authedUser.ID, authedUser.ModPerms)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("studyset not found")
		}
		return nil, fmt.Errorf("failed to update studyset: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &updatedStudyset, nil
}

// CreateTerms is the resolver for the createTerms field.
func (r *mutationResolver) CreateTerms(ctx context.Context, studysetID string, terms []*model.NewTermInput) ([]*model.Term, error) {
	if len(terms) > MaxBatchMutationSize {
		return nil, fmt.Errorf("too many terms in a single request (max %d)", MaxBatchMutationSize)
	}

	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// Check ownership
	var exists bool
	err = tx.QueryRow(ctx, "SELECT exists(SELECT 1 FROM studysets WHERE id = $1 AND user_id = $2)", studysetID, authedUser.ID).Scan(&exists)
	if err != nil {
		return nil, fmt.Errorf("failed to check studyset ownership: %w", err)
	}
	if !exists {
		return nil, fmt.Errorf("studyset not found or not owned by user")
	}

	if len(terms) == 0 {
		return []*model.Term{}, nil
	}

	values := make([]interface{}, 0, len(terms)*4)
	placeholders := make([]string, 0, len(terms))

	for i, t := range terms {
		placeholders = append(placeholders, fmt.Sprintf("($%d,$%d,$%d,$%d)", i*4+1, i*4+2, i*4+3, i*4+4))
		values = append(values, studysetID, t.Term, t.Def, t.SortOrder)
	}

	sql := fmt.Sprintf(`
		INSERT INTO terms (studyset_id, term, def, sort_order)
		VALUES %s
		RETURNING id, term, def, sort_order,
			to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
	`, strings.Join(placeholders, ","))

	var newTerms []*model.Term
	err = pgxscan.Select(ctx, tx, &newTerms, sql, values...)
	if err != nil {
		return nil, fmt.Errorf("failed to insert terms: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return newTerms, nil
}

// UpdateTerms is the resolver for the updateTerms field.
func (r *mutationResolver) UpdateTerms(ctx context.Context, studysetID string, terms []*model.TermInput) ([]*model.Term, error) {
	if len(terms) > MaxBatchMutationSize {
		return nil, fmt.Errorf("too many terms in a single request (max %d)", MaxBatchMutationSize)
	}

	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// Check ownership
	var exists bool
	err = tx.QueryRow(ctx, "SELECT exists(SELECT 1 FROM studysets WHERE id = $1 AND user_id = $2)", studysetID, authedUser.ID).Scan(&exists)
	if err != nil {
		return nil, fmt.Errorf("failed to check studyset ownership: %w", err)
	}
	if !exists {
		return nil, fmt.Errorf("studyset not found or not owned by user")
	}

	if len(terms) == 0 {
		return []*model.Term{}, nil
	}

	values := make([]interface{}, 0, len(terms)*4)
	placeholders := make([]string, 0, len(terms))

	for i, t := range terms {
		placeholders = append(placeholders, fmt.Sprintf(
			"($%d::uuid, $%d::text, $%d::text, $%d::int)",
			i*4+2, i*4+3, i*4+4, i*4+5,
		))
		values = append(values, t.ID, t.Term, t.Def, t.SortOrder)
	}

	sql := fmt.Sprintf(
		`UPDATE terms AS t
		SET term = v.term, def = v.def, sort_order = v.sort_order, updated_at = now()
		FROM (VALUES
			%s
		) AS v(id, term, def, sort_order)
		WHERE t.id = v.id AND t.studyset_id = $1
		RETURNING t.id, t.term, t.def, t.sort_order,
			to_char(t.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
			to_char(t.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at`,
		strings.Join(placeholders, ","),
	)

	var updatedTerms []*model.Term
	err = pgxscan.Select(ctx, tx, &updatedTerms, sql, append([]interface{}{studysetID}, values...)...)
	if err != nil {
		return nil, fmt.Errorf("failed to update terms: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return updatedTerms, nil
}

// DeleteTerms is the resolver for the deleteTerms field.
func (r *mutationResolver) DeleteTerms(ctx context.Context, studysetID string, ids []string) ([]*string, error) {
	if len(ids) > MaxBatchMutationSize {
		return nil, fmt.Errorf("too many items in a single request (max %d)", MaxBatchMutationSize)
	}

	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// Check ownership
	var exists bool
	err = tx.QueryRow(ctx, "SELECT exists(SELECT 1 FROM studysets WHERE id = $1 AND user_id = $2)", studysetID, authedUser.ID).Scan(&exists)
	if err != nil {
		return nil, fmt.Errorf("failed to check studyset ownership: %w", err)
	}
	if !exists {
		return nil, fmt.Errorf("studyset not found or not owned by user")
	}

	if len(ids) == 0 {
		return []*string{}, nil
	}

	var deletedIDs []*string
	sql := "DELETE FROM terms WHERE id = ANY($1) AND studyset_id = $2 RETURNING id"
	err = pgxscan.Select(ctx, tx, &deletedIDs, sql, ids, studysetID)
	if err != nil {
		return nil, fmt.Errorf("failed to delete terms: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return deletedIDs, nil
}

// DeleteStudyset is the resolver for the deleteStudyset field.
func (r *mutationResolver) DeleteStudyset(ctx context.Context, id string) (*string, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	var deletedID string
	err := r.DB.QueryRow(ctx, "DELETE FROM public.studysets WHERE id = $1 AND user_id = $2 RETURNING id", id, authedUser.ID).Scan(&deletedID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, fmt.Errorf("studyset not found")
		}
		return nil, fmt.Errorf("failed to delete studyset: %w", err)
	}

	return &deletedID, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, displayName *string) (*model.AuthedUser, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if displayName != nil {
		trimmedDisplayName := strings.TrimSpace(*displayName)
		if len(trimmedDisplayName) < 1 || len(trimmedDisplayName) > 32 {
			return nil, fmt.Errorf("display name must be between 1 and 32 characters")
		}
		if *displayName != trimmedDisplayName {
			return nil, fmt.Errorf("display name must not have leading or trailing whitespace")
		}
	} else {
		return authedUser, nil
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var updatedUser model.AuthedUser
	err = pgxscan.Get(ctx, tx, &updatedUser,
		`UPDATE auth.users SET display_name = $1 WHERE id = $2 RETURNING id, display_name`,
		*displayName, authedUser.ID)

	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &updatedUser, nil
}

// UpdateTermProgress is the resolver for the updateTermProgress field.
func (r *mutationResolver) UpdateTermProgress(ctx context.Context, termProgress []*model.TermProgressInput) ([]*model.TermProgress, error) {
	if len(termProgress) > MaxBatchMutationSize {
		return nil, fmt.Errorf("too many items in a single request (max %d)", MaxBatchMutationSize)
	}

	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if len(termProgress) == 0 {
		return []*model.TermProgress{}, nil
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// ---- Build bulk insert ----
	valueStrings := make([]string, 0, len(termProgress))
	valueArgs := make([]interface{}, 0, len(termProgress)*10)
	termIDs := make([]string, len(termProgress))

	for i, p := range termProgress {
		termIDs[i] = p.TermID
		// Each row has 10 parameters (adjust if needed)
		base := i*10 + 1
		valueStrings = append(valueStrings, fmt.Sprintf(
			"($%d::uuid,$%d::uuid,$%d::timestamptz,$%d::timestamptz,CASE WHEN $%d IS NOT NULL THEN 1 ELSE 0 END,$%d::timestamptz,$%d::timestamptz,CASE WHEN $%d IS NOT NULL THEN 1 ELSE 0 END,$%d::int,$%d::int,COALESCE($%d::int,0),COALESCE($%d::int,0),COALESCE($%d::int,0),COALESCE($%d::int,0))",
			base, base+1, base+2, base+2, base+2, base+3, base+3, base+3, base+4, base+5, base+6, base+7, base+8, base+9,
		))

		valueArgs = append(valueArgs,
			p.TermID,
			authedUser.ID,
			p.TermReviewedAt,
			p.DefReviewedAt,
			p.TermLeitnerSystemBox,
			p.DefLeitnerSystemBox,
			p.TermCorrectIncrease,
			p.TermIncorrectIncrease,
			p.DefCorrectIncrease,
			p.DefIncorrectIncrease,
		)
	}

	query := fmt.Sprintf(`
		INSERT INTO term_progress (
			term_id, user_id,
			term_first_reviewed_at, term_last_reviewed_at,
			term_review_count,
			def_first_reviewed_at, def_last_reviewed_at,
			def_review_count,
			term_leitner_system_box, def_leitner_system_box,
			term_correct_count, term_incorrect_count,
			def_correct_count, def_incorrect_count
		)
		SELECT v.term_id::uuid, v.user_id::uuid,
			v.term_first_reviewed_at::timestamptz, v.term_last_reviewed_at::timestamptz,
			v.term_review_count::int,
			v.def_first_reviewed_at::timestamptz, v.def_last_reviewed_at::timestamptz,
			v.def_review_count::int,
			v.term_leitner_system_box::int, v.def_leitner_system_box::int,
			v.term_correct_count::int, v.term_incorrect_count::int,
			v.def_correct_count::int, v.def_incorrect_count::int
		FROM (VALUES %s) AS v(
			term_id, user_id,
			term_first_reviewed_at, term_last_reviewed_at,
			term_review_count,
			def_first_reviewed_at, def_last_reviewed_at,
			def_review_count,
			term_leitner_system_box, def_leitner_system_box,
			term_correct_count, term_incorrect_count,
			def_correct_count, def_incorrect_count
		)
		JOIN terms t ON t.id = v.term_id::uuid
		JOIN studysets s ON s.id = t.studyset_id
		WHERE s.private = false OR s.user_id = v.user_id::uuid
		ON CONFLICT (term_id, user_id) DO UPDATE SET
			term_last_reviewed_at = COALESCE(EXCLUDED.term_last_reviewed_at, term_progress.term_last_reviewed_at),
			def_last_reviewed_at = COALESCE(EXCLUDED.def_last_reviewed_at, term_progress.def_last_reviewed_at),
			term_leitner_system_box = EXCLUDED.term_leitner_system_box,
			def_leitner_system_box = EXCLUDED.def_leitner_system_box,
			term_review_count = term_progress.term_review_count +
				(CASE WHEN EXCLUDED.term_last_reviewed_at IS NOT NULL THEN 1 ELSE 0 END),
			def_review_count = term_progress.def_review_count +
				(CASE WHEN EXCLUDED.def_last_reviewed_at IS NOT NULL THEN 1 ELSE 0 END),
			term_correct_count = term_progress.term_correct_count + EXCLUDED.term_correct_count,
			term_incorrect_count = term_progress.term_incorrect_count + EXCLUDED.term_incorrect_count,
			def_correct_count = term_progress.def_correct_count + EXCLUDED.def_correct_count,
			def_incorrect_count = term_progress.def_incorrect_count + EXCLUDED.def_incorrect_count
		RETURNING term_progress.id,
			to_char(term_progress.term_first_reviewed_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as term_first_reviewed_at,
			to_char(term_progress.term_last_reviewed_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as term_last_reviewed_at,
			term_progress.term_review_count,
			to_char(term_progress.def_first_reviewed_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as def_first_reviewed_at,
			to_char(term_progress.def_last_reviewed_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as def_last_reviewed_at,
			term_progress.def_review_count,
			term_progress.term_leitner_system_box, term_progress.def_leitner_system_box,
			term_progress.term_correct_count, term_progress.term_incorrect_count,
			term_progress.def_correct_count, term_progress.def_incorrect_count
	`, strings.Join(valueStrings, ","))

	var results []*model.TermProgress
	if err := pgxscan.Select(ctx, tx, &results, query, valueArgs...); err != nil {
		return nil, fmt.Errorf("bulk upsert failed: %w", err)
	}

	if len(results) != len(termProgress) {
		return nil, fmt.Errorf("some terms not found or not accessible")
	}

	// ---- Bulk insert into history ----
	if len(results) > 0 {
		histVals := make([]string, 0, len(results))
		histArgs := make([]interface{}, 0, len(results)*6)
		for i, tp := range results {
			base := i*6 + 1
			histVals = append(histVals, fmt.Sprintf("($%d,$%d,$%d,$%d,$%d,$%d)", base, base+1, base+2, base+3, base+4, base+5))
			histArgs = append(histArgs,
				authedUser.ID,
				termIDs[i],
				tp.TermCorrectCount,
				tp.TermIncorrectCount,
				tp.DefCorrectCount,
				tp.DefIncorrectCount,
			)
		}
		histQuery := fmt.Sprintf(`
			INSERT INTO term_progress_history (
				user_id, term_id, term_correct_count, term_incorrect_count,
				def_correct_count, def_incorrect_count
			) VALUES %s`, strings.Join(histVals, ","))

		if _, err := tx.Exec(ctx, histQuery, histArgs...); err != nil {
			return nil, fmt.Errorf("failed to insert into term_progress_history: %w", err)
		}
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return results, nil
}

// RecordConfusedTerms is the resolver for the recordConfusedTerms field.
func (r *mutationResolver) RecordConfusedTerms(ctx context.Context, confusedTerms []*model.TermConfusionPairInput) (*bool, error) {
	var success bool
	if len(confusedTerms) > MaxBatchMutationSize {
		success = false
		return &success, fmt.Errorf("too many items in a single request (max %d)", MaxBatchMutationSize)
	}

	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		success = false
		return &success, fmt.Errorf("not authenticated")
	}

	if len(confusedTerms) == 0 {
		success = false
		return &success, nil
	}

	values := make([]interface{}, 0, len(confusedTerms)*5)
	values = append(
		values,
		*authedUser.ID,
	)
	placeholders := make([]string, 0, len(confusedTerms))

	for i, ct := range confusedTerms {
		placeholders = append(
			placeholders,
			fmt.Sprintf(
				"($1,$%d,$%d,$%d,$%d,$%d)",
				i*5+2, i*5+3, i*5+4, i*5+5, i*5+6,
			),
		)
		values = append(
			values,
			ct.TermID,
			ct.ConfusedTermID,
			ct.AnsweredWith,
			ct.ConfusedCountIncrease,
			ct.ConfusedAt,
		)
	}

	sql := fmt.Sprintf(`INSERT INTO term_confusion_pairs (
	user_id, term_id, confused_term_id, answered_with, confused_count, last_confused_at
)
SELECT v.user_id, v.term_id, v.confused_term_id, v.answered_with, v.confused_count, v.last_confused_at
FROM (VALUES %s) AS v(user_id, term_id, confused_term_id, answered_with, confused_count, last_confused_at)
JOIN terms t1 ON t1.id = v.term_id::uuid
JOIN studysets s1 ON s1.id = t1.studyset_id
JOIN terms t2 ON t2.id = v.confused_term_id::uuid
JOIN studysets s2 ON s2.id = t2.studyset_id
WHERE (s1.private = false OR s1.user_id = v.user_id::uuid)
  AND (s2.private = false OR s2.user_id = v.user_id::uuid)
ON CONFLICT (user_id, term_id, confused_term_id, answered_with)
DO UPDATE SET confused_count = term_confusion_pairs.confused_count + EXCLUDED.confused_count,
	last_confused_at = EXCLUDED.last_confused_at`,
		strings.Join(placeholders, ","),
	)
	_, err := r.DB.Exec(ctx, sql, values...)
	if err != nil {
		success = false
		return &success, fmt.Errorf("failed to insert/update confusion pairs: %w", err)
	}

	success = true
	return &success, nil
}

// RecordPracticeTest is the resolver for the recordPracticeTest field.
func (r *mutationResolver) RecordPracticeTest(ctx context.Context, input *model.PracticeTestInput) (*model.PracticeTest, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	var practiceTest model.PracticeTest
	err := pgxscan.Get(
		ctx,
		r.DB,
		&practiceTest,
		`INSERT INTO practice_tests
	(timestamp, user_id, studyset_id, questions_correct, questions_total, questions)
SELECT now(), $1, s.id, $3, $4, $5
FROM studysets s
WHERE s.id = $2 AND (s.private = false OR s.user_id = $1)
RETURNING
	id,
	to_char(timestamp, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as timestamp,
	questions_correct,
	questions_total,
	questions`,
		authedUser.ID,
		input.StudysetID,
		input.QuestionsCorrect,
		input.QuestionsTotal,
		input.Questions,
	)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("studyset not found or not accessible")
		}
		return nil, fmt.Errorf("database error in RecordPracticeTest: %w", err)
	}

	return &practiceTest, nil
}

// UpdatePracticeTest is the resolver for the updatePracticeTest field.
func (r *mutationResolver) UpdatePracticeTest(ctx context.Context, input *model.PracticeTestInput) (*model.PracticeTest, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if input.ID == nil {
		return nil, fmt.Errorf("practice test id cannot be null when updating")
	}

	var practiceTest model.PracticeTest
	err := pgxscan.Get(
		ctx,
		r.DB,
		&practiceTest,
		`UPDATE practice_tests SET questions_correct = $3, questions_total = $4, questions = $5
WHERE user_id = $1 AND id = $2
RETURNING
	id,
	to_char(timestamp, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as timestamp,
	questions_correct,
	questions_total,
	questions`,
		authedUser.ID,
		input.ID,
		input.QuestionsCorrect,
		input.QuestionsTotal,
		input.Questions,
	)
	if err != nil {
		return nil, fmt.Errorf("database error in updatePracticeTest: %w", err)
	}

	return &practiceTest, nil
}

// CreateFolder is the resolver for the createFolder field.
func (r *mutationResolver) CreateFolder(ctx context.Context, name string) (*model.Folder, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if len(name) > MaxFolderNameLen {
		name = name[:MaxFolderNameLen]
	}

	sql := `
		INSERT INTO folders (user_id, name)
		VALUES ($1, $2)
		RETURNING id, name
	`
	var newFolder model.Folder
	err := pgxscan.Get(ctx, r.DB, &newFolder, sql, authedUser.ID, name)
	if err != nil {
		return nil, fmt.Errorf("failed to create studyset: %w", err)
	}

	return &newFolder, nil
}

// RenameFolder is the resolver for the renameFolder field.
func (r *mutationResolver) RenameFolder(ctx context.Context, id string, name string) (*model.Folder, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if len(name) > MaxFolderNameLen {
		name = name[:MaxFolderNameLen]
	}

	sql := `
		UPDATE folders SET name = $1
		WHERE user_id = $2 AND id = $3
		RETURNING id, name
	`
	var folder model.Folder
	err := pgxscan.Get(ctx, r.DB, &folder, sql, name, authedUser.ID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to rename folder: %w", err)
	}

	return &folder, nil
}

// DeleteFolder is the resolver for the deleteFolder field.
func (r *mutationResolver) DeleteFolder(ctx context.Context, id string) (*string, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	_, err := r.DB.Exec(
		ctx,
		"DELETE FROM folders WHERE id = $1 AND user_id = $2",
		id,
		authedUser.ID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to delete folder: %w", err)
	}

	return &id, nil
}

// SetStudysetFolder is the resolver for the setStudysetFolder field.
func (r *mutationResolver) SetStudysetFolder(ctx context.Context, studysetID string, folderID string) (*bool, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	_, err := r.DB.Exec(
		ctx,
		`INSERT INTO folder_studysets (user_id, studyset_id, folder_id)
		SELECT $1, s.id, f.id
		FROM studysets s
		JOIN folders f ON f.id = $3::uuid
		WHERE s.id = $2::uuid
		  AND (s.private = false OR s.user_id = $1)
		  AND f.user_id = $1
		ON CONFLICT (user_id, studyset_id) DO UPDATE
		SET folder_id = EXCLUDED.folder_id`,
		authedUser.ID,
		studysetID,
		folderID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to add/move studyset to folder: %w", err)
	}

	yay := true
	return &yay, nil
}

// RemoveStudysetFromFolder is the resolver for the removeStudysetFromFolder field.
func (r *mutationResolver) RemoveStudysetFromFolder(ctx context.Context, studysetID string) (*bool, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	_, err := r.DB.Exec(
		ctx,
		"DELETE FROM folder_studysets WHERE studyset_id = $1 AND user_id = $2",
		studysetID,
		authedUser.ID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to unsave studyset: %w", err)
	}

	yay := true
	return &yay, nil
}

// SaveStudyset is the resolver for the saveStudyset field.
func (r *mutationResolver) SaveStudyset(ctx context.Context, studysetID string) (*bool, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	_, err := r.DB.Exec(
		ctx,
		`INSERT INTO saved_studysets (user_id, studyset_id)
		SELECT $1, id FROM studysets
		WHERE id = $2 AND (private = false OR user_id = $1)`,
		authedUser.ID,
		studysetID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to save studyset: %w", err)
	}

	yay := true
	return &yay, nil
}

// UnsaveStudyset is the resolver for the unsaveStudyset field.
func (r *mutationResolver) UnsaveStudyset(ctx context.Context, studysetID string) (*bool, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	_, err := r.DB.Exec(
		ctx,
		"DELETE FROM saved_studysets WHERE studyset_id = $1 AND user_id = $2",
		studysetID,
		authedUser.ID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to unsave studyset: %w", err)
	}

	yay := true
	return &yay, nil
}

// Authed is the resolver for the authed field.
func (r *queryResolver) Authed(ctx context.Context) (*bool, error) {
	authed := auth.AuthedUserContext(ctx) != nil
	return &authed, nil
}

// AuthedUser is the resolver for the authedUser field.
func (r *queryResolver) AuthedUser(ctx context.Context) (*model.AuthedUser, error) {
	return auth.AuthedUserContext(ctx), nil
}

// Studyset is the resolver for the studyset field.
func (r *queryResolver) Studyset(ctx context.Context, id string) (*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)

	var studyset model.Studyset
	var err error
	if authedUser != nil {
		sql := `
			SELECT id, user_id, title, private, subject_id,
				to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM public.studysets
			WHERE id = $1 AND (private = false OR (private = true AND user_id = $2))`
		err = pgxscan.Get(ctx, r.DB, &studyset, sql, id, authedUser.ID)
	} else {
		sql := `
			SELECT id, user_id, title, private,
				to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM public.studysets
			WHERE id = $1 AND private = false`
		err = pgxscan.Get(ctx, r.DB, &studyset, sql, id)
	}
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("studyset not found")
		}
		return nil, fmt.Errorf("failed to fetch studyset: %w", err)
	}

	return &studyset, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	var user model.User
	sql := `
		SELECT
			id,
			username,
			display_name
		FROM auth.users
		WHERE id = $1
	`
	err := pgxscan.Get(ctx, r.DB, &user, sql, id)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}
	return &user, nil
}

// Term is the resolver for the term field.
func (r *queryResolver) Term(ctx context.Context, id string) (*model.Term, error) {
	authedUser := auth.AuthedUserContext(ctx)

	var term model.Term
	var err error
	if authedUser != nil {
		err = pgxscan.Get(
			ctx,
			r.DB,
			&term,
			`SELECT terms.id, terms.term, terms.def, terms.sort_order,
		to_char(terms.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
		to_char(terms.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
FROM terms
JOIN studysets ON terms.studyset_id = studysets.id
WHERE terms.id = $1 AND (
    	studysets.private = FALSE OR
		studysets.user_id = $2
)`,
			id,
			authedUser.ID,
		)
	} else {
		err = pgxscan.Get(
			ctx,
			r.DB,
			&term,
			`SELECT terms.id, terms.term, terms.def, terms.sort_order,
		to_char(terms.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
		to_char(terms.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
FROM terms
JOIN studysets ON terms.studyset_id = studysets.id
WHERE terms.id = $1 AND studysets.private = FALSE`,
			id,
		)
	}
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("term not found")
		}
		return nil, fmt.Errorf("failed to fetch term: %w", err)
	}

	return &term, nil
}

// RecentlyCreatedStudysets is the resolver for the recentlyCreatedStudysets field.
func (r *queryResolver) RecentlyCreatedStudysets(ctx context.Context, first *int32, after *string, last *int32, before *string) (*model.StudysetConnection, error) {
	l := 24
	if first != nil && *first > 0 && *first < 1000 {
		l = int(*first)
	} else if last != nil && *last > 0 && *last < 1000 {
		l = int(*last)
	}
	limit := l + 1

	cursorScore, cursorID := DecodeStudysetCursor(ptrToString(after))
	beforeCursorScore, beforeCursorID := DecodeStudysetCursor(ptrToString(before))

	// Check for Previous Page possibility
	hasPrevious := cursorScore != "" || cursorID != ""
	if before != nil {
		// If we are paginating backwards, there is always a "next" page (which is the one we came from)
		// but in the context of "hasPrevious", it means "are there newer items?"
		// When going backwards (using before), we are moving towards newer items.
		// If we find more than limit, it means there are even newer items.
		// For the sake of the connection spec:
		// hasNextPage: false (usually, unless we fetched more than limit)
		// hasPreviousPage: true (we assume there are older items if we are in the middle)
		// But let's stick to the data:
	}

	var studysets []*model.Studyset
	var err error

	if beforeCursorID != "" {
		// Backward pagination
		// We want items NEWER than the cursor, sorted ASC (oldest to newest) to get the "previous" 24 items
		// Then we reverse them back to DESC (newest to oldest) for the client.

		sql := `
			SELECT
				id,
				user_id,
				title,
				private,
				subject_id,
				to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM public.studysets
			WHERE private = false
				AND (to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), id) > ($1, $2::uuid)
			ORDER BY created_at ASC, id ASC
			LIMIT $3
		`
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, beforeCursorScore, beforeCursorID, limit)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch recently created studysets: %w", err)
		}

		// If we found more than the limit, it means there is a "previous" page (newer items)
		hasPrevious = len(studysets) > l
		if hasPrevious {
			studysets = studysets[:l]
		}

		// Reverse connections to restore DESC order
		for i, j := 0, len(studysets)-1; i < j; i, j = i+1, j-1 {
			studysets[i], studysets[j] = studysets[j], studysets[i]
		}

		// Since we moved backwards, we know there is a "next" page (older items, where we came from)
		// strictly speaking, unless we are at the very beginning of the list?
		// No, if we successfully fetched items using `before`, it implies we are not at the end.
		// But we need to know if there are MORE older items. `hasPrevious` check above tells us if there are NEWER.
		// To know if there are OLDER items (hasNextPage), we'd typically rely on where we came from or do a peek.
		// For simple prev/next buttons, we can assume:
		// If we utilized `before`, we definitely have `hasNextPage` = true (the page we came from).

	} else if cursorID != "" {
		// Forward pagination
		sql := `
			SELECT
				id,
				user_id,
				title,
				private,
				subject_id,
				to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM public.studysets
			WHERE private = false
				AND (to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), id) < ($1, $2::uuid)
			ORDER BY created_at DESC, id DESC
			LIMIT $3
		`
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, cursorScore, cursorID, limit)
	} else {
		// First page
		sql := `
			SELECT
				id,
				user_id,
				title,
				private,
				subject_id,
				to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM public.studysets
			WHERE private = false
			ORDER BY created_at DESC, id DESC
			LIMIT $1
		`
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, limit)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to fetch recently created studysets: %w", err)
	}

	hasNext := false
	if beforeCursorID != "" {
		// If we went backwards, we assume there's a next page (older items)
		// This is a simplification but sufficient for linear navigation
		hasNext = true
	} else {
		hasNext = len(studysets) > l
		if hasNext {
			studysets = studysets[:l]
		}
	}

	getCursor := func(s *model.Studyset) (string, string) {
		return ptrToString(s.CreatedAt), ptrToString(s.ID)
	}
	return StudysetConnectionFrom(studysets, hasNext, hasPrevious, getCursor), nil
}

// RecentlyUpdatedStudysets is the resolver for the recentlyUpdatedStudysets field.
func (r *queryResolver) RecentlyUpdatedStudysets(ctx context.Context, first *int32, after *string, last *int32, before *string) (*model.StudysetConnection, error) {
	l := 24
	if first != nil && *first > 0 && *first < 1000 {
		l = int(*first)
	} else if last != nil && *last > 0 && *last < 1000 {
		l = int(*last)
	}
	limit := l + 1

	cursorScore, cursorID := DecodeStudysetCursor(ptrToString(after))
	beforeCursorScore, beforeCursorID := DecodeStudysetCursor(ptrToString(before))

	// Check for Previous Page possibility
	hasPrevious := cursorScore != "" || cursorID != ""
	if before != nil {

	}

	var studysets []*model.Studyset
	var err error

	if beforeCursorID != "" {
		// Backward pagination
		// We want items NEWER than the cursor, sorted ASC (oldest to newest) to get the "previous" 24 items
		// Then we reverse them back to DESC (newest to oldest) for the client.

		sql := `
			SELECT
				id,
				user_id,
				title,
				private,
				subject_id,
				to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM public.studysets
			WHERE private = false
				AND (to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), id) > ($1, $2::uuid)
			ORDER BY updated_at ASC, id ASC
			LIMIT $3
		`
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, beforeCursorScore, beforeCursorID, limit)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch recently updated studysets: %w", err)
		}

		// If we found more than the limit, it means there is a "previous" page (newer items)
		hasPrevious = len(studysets) > l
		if hasPrevious {
			studysets = studysets[:l]
		}

		// Reverse connections to restore DESC order
		for i, j := 0, len(studysets)-1; i < j; i, j = i+1, j-1 {
			studysets[i], studysets[j] = studysets[j], studysets[i]
		}

	} else if cursorID != "" {
		// Forward pagination
		sql := `
			SELECT
				id,
				user_id,
				title,
				private,
				subject_id,
				to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM public.studysets
			WHERE private = false
				AND (to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), id) < ($1, $2::uuid)
			ORDER BY updated_at DESC, id DESC
			LIMIT $3
		`
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, cursorScore, cursorID, limit)
	} else {
		// First page
		sql := `
			SELECT
				id,
				user_id,
				title,
				private,
				subject_id,
				to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM public.studysets
			WHERE private = false
			ORDER BY updated_at DESC, id DESC
			LIMIT $1
		`
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, limit)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to fetch recently updated studysets: %w", err)
	}

	hasNext := false
	if beforeCursorID != "" {
		// If we went backwards, we assume there's a next page (older items)
		// This is a simplification but sufficient for linear navigation
		hasNext = true
	} else {
		hasNext = len(studysets) > l
		if hasNext {
			studysets = studysets[:l]
		}
	}

	getCursor := func(s *model.Studyset) (string, string) {
		return ptrToString(s.UpdatedAt), ptrToString(s.ID)
	}
	return StudysetConnectionFrom(studysets, hasNext, hasPrevious, getCursor), nil
}

// SearchStudysets is the resolver for the searchStudysets field.
func (r *queryResolver) SearchStudysets(ctx context.Context, q string, first *int32, after *string, last *int32, before *string) (*model.StudysetConnection, error) {
	if len(q) < 1 {
		return &model.StudysetConnection{
			Edges:    []*model.StudysetEdge{},
			PageInfo: &model.PageInfo{},
		}, nil
	}
	// limit query length before using it with the database because `word_similarity` can become really heavy
	if len(q) > 200 {
		q = q[:200]
	}
	l := 240
	if first != nil && *first > 0 && *first < 1000 {
		l = int(*first)
	} else if last != nil && *last > 0 && *last < 1000 {
		l = int(*last)
	}
	limit := l + 1

	cursorScore, cursorTS, cursorID := DecodeStudysetScoreCursor(ptrToString(after))
	beforeCursorScore, beforeCursorTS, beforeCursorID := DecodeStudysetScoreCursor(ptrToString(before))

	isBackward := beforeCursorID != ""
	hasPrevious := false
	if !isBackward {
		hasPrevious = cursorScore != "" || cursorTS != "" || cursorID != ""
	}

	// We need a temporary struct to hold the score for cursor generation
	type searchRow struct {
		model.Studyset
		Score float64 `db:"score"`
	}

	var rows []*searchRow
	var err error

	// Common select columns matching model.Studyset fields (via scany/db tags or name matching)
	selectCols := `
		id,
		user_id,
		title,
		private,
		subject_id,
		to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
		to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at,
		word_similarity(lower($1), lower(title)) as score
	`

	if isBackward {
		sql := `
			SELECT ` + selectCols + `
			FROM public.studysets
			WHERE lower($1) <% lower(title) AND private = false
				AND (word_similarity(lower($1), lower(title)), to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), id) > ($2::float4, $3, $4::uuid)
			ORDER BY score ASC, created_at ASC, id ASC
			LIMIT $5
		`
		err = pgxscan.Select(ctx, r.DB, &rows, sql, q, beforeCursorScore, beforeCursorTS, beforeCursorID, limit)
		if err == nil {
			// If we found more than the limit, it means there is a "previous" page (newer items)
			hasPrevious = len(rows) > l
			if hasPrevious {
				rows = rows[:l]
			}
			// Reverse results to restore DESC order
			for i, j := 0, len(rows)-1; i < j; i, j = i+1, j-1 {
				rows[i], rows[j] = rows[j], rows[i]
			}
		}
	} else if cursorID != "" {
		sql := `
			SELECT ` + selectCols + `
			FROM public.studysets
			WHERE lower($1) <% lower(title) AND private = false
				AND (word_similarity(lower($1), lower(title)), to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), id) < ($2::float4, $3, $4::uuid)
			ORDER BY score DESC, created_at DESC, id DESC
			LIMIT $5
		`
		// cursorScore is passed as string, Postgres will parse it with ::float4
		err = pgxscan.Select(ctx, r.DB, &rows, sql, q, cursorScore, cursorTS, cursorID, limit)
	} else {
		// No cursor
		sql := `
			SELECT ` + selectCols + `
			FROM public.studysets
			WHERE lower($1) <% lower(title) AND private = false
			ORDER BY score DESC, created_at DESC, id DESC
			LIMIT $2
		`
		err = pgxscan.Select(ctx, r.DB, &rows, sql, q, limit)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to search studysets: %w", err)
	}

	hasNext := false
	if isBackward {
		hasNext = true
	} else {
		hasNext = len(rows) > l
		if hasNext {
			rows = rows[:l]
		}
	}

	// Convert back to []*model.Studyset for the connection
	studysets := make([]*model.Studyset, len(rows))
	for i, r := range rows {
		// Make a copy or point to the embedded struct?
		// r.Studyset is embedded. We can take address of it?
		// Be careful with loop variable capturing.
		// Actually, r is a pointer to searchRow.
		// We can just return &row.Studyset?
		// Yes, r.Studyset is the struct value embedded. &r.Studyset works.
		s := r.Studyset
		studysets[i] = &s
	}

	// Manual connection building
	edges := make([]*model.StudysetEdge, 0, len(studysets))
	for i, s := range studysets {
		score := rows[i].Score
		edges = append(edges, &model.StudysetEdge{
			Node:   s,
			Cursor: EncodeStudysetScoreCursor(fmt.Sprintf("%f", score), ptrToString(s.CreatedAt), ptrToString(s.ID)),
		})
	}

	var startCursor, endCursor *string
	if len(edges) > 0 {
		startCursor = &edges[0].Cursor
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &model.StudysetConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNext,
			HasPreviousPage: hasPrevious,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
	}, nil

	// Note: I am not using StudysetConnectionFrom because it hardcodes EncodeStudysetCursor.
	// `getCursor` var above was just to show I considered it.
}

// MyStudysets is the resolver for the myStudysets field.
func (r *queryResolver) MyStudysets(ctx context.Context, first *int32, after *string, last *int32, before *string, hideFoldered *bool) (*model.StudysetConnection, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	l := 240
	if first != nil && *first > 0 && *first < 1000 {
		l = int(*first)
	} else if last != nil && *last > 0 && *last < 1000 {
		l = int(*last)
	}
	limit := l + 1

	cursorTS, cursorID := DecodeStudysetCursor(ptrToString(after))
	beforeCursorTS, beforeCursorID := DecodeStudysetCursor(ptrToString(before))

	isBackward := beforeCursorID != ""
	hasPrevious := false
	if !isBackward {
		hasPrevious = cursorTS != "" || cursorID != ""
	}

	var studysets []*model.Studyset
	var err error

	// Common columns for selectivity
	cols := `id, user_id, title, private, subject_id,
				to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at`

	// Where clause fragments
	whereBase := `WHERE user_id = $1`
	if hideFoldered != nil && *hideFoldered {
		whereBase += ` AND id NOT IN (SELECT fs.studyset_id FROM folder_studysets fs WHERE fs.user_id = $1)`
	}

	if isBackward {
		sql := fmt.Sprintf(`
			SELECT %s
			FROM public.studysets
			%s AND (to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), id) > ($2, $3::uuid)
			ORDER BY updated_at ASC, id ASC
			LIMIT $4
		`, cols, whereBase)
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, authedUser.ID, beforeCursorTS, beforeCursorID, limit)
		if err == nil {
			hasPrevious = len(studysets) > l
			if hasPrevious {
				studysets = studysets[:l]
			}
			// Reverse
			for i, j := 0, len(studysets)-1; i < j; i, j = i+1, j-1 {
				studysets[i], studysets[j] = studysets[j], studysets[i]
			}
		}
	} else if cursorID != "" {
		sql := fmt.Sprintf(`
			SELECT %s
			FROM public.studysets
			%s AND (to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), id) < ($2, $3::uuid)
			ORDER BY updated_at DESC, id DESC
			LIMIT $4
		`, cols, whereBase)
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, authedUser.ID, cursorTS, cursorID, limit)
	} else {
		sql := fmt.Sprintf(`
			SELECT %s
			FROM public.studysets
			%s
			ORDER BY updated_at DESC, id DESC
			LIMIT $2
		`, cols, whereBase)
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, authedUser.ID, limit)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to fetch my studysets: %w", err)
	}

	hasNext := false
	if isBackward {
		hasNext = true
	} else {
		hasNext = len(studysets) > l
		if hasNext {
			studysets = studysets[:l]
		}
	}
	getCursor := func(s *model.Studyset) (string, string) {
		return ptrToString(s.UpdatedAt), ptrToString(s.ID)
	}
	return StudysetConnectionFrom(studysets, hasNext, hasPrevious, getCursor), nil
}

// MyFolders is the resolver for the myFolders field.
func (r *queryResolver) MyFolders(ctx context.Context, first *int32, after *string) (*model.FolderConnection, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	l := 240
	if first != nil && *first > 0 && *first < 1000 {
		l = int(*first)
	}
	limit := l + 1

	cursorID := DecodeFolderCursor(ptrToString(after))
	hasPrevious := cursorID != ""

	var folders []*model.Folder
	var err error
	if cursorID != "" {
		sql := `
			SELECT id, name
			FROM folders
			WHERE user_id = $1 AND id < $2::uuid
			ORDER BY id DESC
			LIMIT $3
		`
		err = pgxscan.Select(ctx, r.DB, &folders, sql, authedUser.ID, cursorID, limit)
	} else {
		sql := `
			SELECT id, name
			FROM folders
			WHERE user_id = $1
			ORDER BY id DESC
			LIMIT $2
		`
		err = pgxscan.Select(ctx, r.DB, &folders, sql, authedUser.ID, limit)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to fetch my folders: %w", err)
	}

	hasNext := len(folders) > l
	if hasNext {
		folders = folders[:l]
	}
	edges := make([]*model.FolderEdge, 0, len(folders))
	for _, f := range folders {
		idStr := ptrToString(f.ID)
		edges = append(edges, &model.FolderEdge{
			Node:   f,
			Cursor: EncodeFolderCursor(idStr),
		})
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		startCursor = &edges[0].Cursor
		endCursor = &edges[len(edges)-1].Cursor
	}
	return &model.FolderConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNext,
			HasPreviousPage: hasPrevious,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
	}, nil
}

// MySavedStudysets is the resolver for the mySavedStudysets field.
func (r *queryResolver) MySavedStudysets(ctx context.Context, first *int32, after *string, last *int32, before *string) (*model.StudysetConnection, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	l := 240
	if first != nil && *first > 0 && *first < 1000 {
		l = int(*first)
	} else if last != nil && *last > 0 && *last < 1000 {
		l = int(*last)
	}
	limit := l + 1

	cursorTS, cursorID := DecodeStudysetCursor(ptrToString(after))
	beforeCursorTS, beforeCursorID := DecodeStudysetCursor(ptrToString(before))

	isBackward := beforeCursorID != ""
	hasPrevious := false
	if !isBackward {
		hasPrevious = cursorTS != "" || cursorID != ""
	}

	var rows []*SavedStudysetRow
	var err error
	if isBackward {
		sql := `
			SELECT
				s.id,
				s.user_id,
				s.title,
				s.private,
				s.subject_id,
				to_char(s.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(s.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at,
				to_char(saved_studysets.timestamp, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as saved_at
			FROM saved_studysets
			JOIN studysets s ON saved_studysets.studyset_id = s.id
			WHERE saved_studysets.user_id = $1
				AND s.private = false
				AND (to_char(saved_studysets.timestamp, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), s.id) > ($2, $3::uuid)
			ORDER BY saved_studysets.timestamp ASC, s.id ASC
			LIMIT $4
		`
		err = pgxscan.Select(ctx, r.DB, &rows, sql, authedUser.ID, beforeCursorTS, beforeCursorID, limit)
		if err == nil {
			hasPrevious = len(rows) > l
			if hasPrevious {
				rows = rows[:l]
			}
			// Reverse
			for i, j := 0, len(rows)-1; i < j; i, j = i+1, j-1 {
				rows[i], rows[j] = rows[j], rows[i]
			}
		}
	} else if cursorID != "" {
		sql := `
			SELECT
				s.id,
				s.user_id,
				s.title,
				s.private,
				s.subject_id,
				to_char(s.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(s.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at,
				to_char(saved_studysets.timestamp, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as saved_at
			FROM saved_studysets
			JOIN studysets s ON saved_studysets.studyset_id = s.id
			WHERE saved_studysets.user_id = $1
				AND s.private = false
				AND (to_char(saved_studysets.timestamp, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), s.id) < ($2, $3::uuid)
			ORDER BY saved_studysets.timestamp DESC, s.id DESC
			LIMIT $4
		`
		err = pgxscan.Select(ctx, r.DB, &rows, sql, authedUser.ID, cursorTS, cursorID, limit)
	} else {
		sql := `
			SELECT
				s.id,
				s.user_id,
				s.title,
				s.private,
				s.subject_id,
				to_char(s.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(s.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at,
				to_char(saved_studysets.timestamp, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as saved_at
			FROM saved_studysets
			JOIN studysets s ON saved_studysets.studyset_id = s.id
			WHERE saved_studysets.user_id = $1
				AND s.private = false
			ORDER BY saved_studysets.timestamp DESC, s.id DESC
			LIMIT $2
		`
		err = pgxscan.Select(ctx, r.DB, &rows, sql, authedUser.ID, limit)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to fetch saved studysets: %w", err)
	}

	hasNext := false
	if isBackward {
		hasNext = true
	} else {
		hasNext = len(rows) > l
		if hasNext {
			rows = rows[:l]
		}
	}
	edges := make([]*model.StudysetEdge, 0, len(rows))
	for _, row := range rows {
		edges = append(edges, &model.StudysetEdge{
			Node:   &row.Studyset,
			Cursor: EncodeStudysetCursor(ptrToString(row.SavedAt), ptrToString(row.ID)),
		})
	}
	var startCursor, endCursor *string
	if len(edges) > 0 {
		startCursor = &edges[0].Cursor
		endCursor = &edges[len(edges)-1].Cursor
	}
	return &model.StudysetConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNext,
			HasPreviousPage: hasPrevious,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
	}, nil
}

// PracticeTest is the resolver for the practiceTest field.
func (r *queryResolver) PracticeTest(ctx context.Context, id string) (*model.PracticeTest, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	var practiceTest model.PracticeTest
	err := pgxscan.Get(
		ctx,
		r.DB,
		&practiceTest,
		`SELECT id,
	studyset_id,
	to_char(timestamp, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as timestamp,
	questions_correct,
	questions_total,
	questions
FROM practice_tests
WHERE id = $1 AND user_id = $2`,
		id,
		authedUser.ID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch practice test by id: %w", err)
	}

	return &practiceTest, nil
}

// Subject is the resolver for the subject field.
func (r *queryResolver) Subject(ctx context.Context, id string) (*model.Subject, error) {
	var subject model.Subject
	err := pgxscan.Get(
		ctx,
		r.DB,
		&subject,
		`SELECT id, name, category
FROM subjects WHERE id = $1`,
		id,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get subject by id: %w", err)
	}

	return &subject, nil
}

// SubjectsByKeyword is the resolver for the subjectsByKeyword field.
func (r *queryResolver) SubjectsByKeyword(ctx context.Context, keyword *string) ([]*model.Subject, error) {
	var subjects []*model.Subject
	err := pgxscan.Select(
		ctx,
		r.DB,
		&subjects,
		`SELECT s.id, s.name, s.category
FROM subjects s
JOIN subject_keywords sk ON sk.subject_id = s.id
WHERE sk.keyword = $1`,
		keyword,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get subject by id: %w", err)
	}

	return subjects, nil
}

// SubjectsByCategory is the resolver for the subjectsByCategory field.
func (r *queryResolver) SubjectsByCategory(ctx context.Context, category *model.SubjectCategory) ([]*model.Subject, error) {
	var subjects []*model.Subject
	err := pgxscan.Select(
		ctx,
		r.DB,
		&subjects,
		`SELECT id, name, category
FROM subjects
WHERE category = $1`,
		category,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get subjects by category: %w", err)
	}

	return subjects, nil
}

// AllSubjects is the resolver for the allSubjects field.
func (r *queryResolver) AllSubjects(ctx context.Context) ([]*model.Subject, error) {
	var subjects []*model.Subject
	err := pgxscan.Select(
		ctx,
		r.DB,
		&subjects,
		`SELECT id, name, category FROM subjects`,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get all subjects: %w", err)
	}

	return subjects, nil
}

// Folder is the resolver for the folder field.
func (r *queryResolver) Folder(ctx context.Context, id string) (*model.Folder, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	var folder model.Folder
	sql := `
		SELECT
			id,
			name
		FROM folders
		WHERE id = $1 AND user_id = $2
	`
	err := pgxscan.Get(ctx, r.DB, &folder, sql, id, authedUser.ID)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get folder: %w", err)
	}

	return &folder, nil
}

// StudysetCount is the resolver for the studysetCount field.
func (r *queryResolver) StudysetCount(ctx context.Context, after *string, includePrivate *bool) (int32, error) {
	incPrivate := false
	if includePrivate != nil {
		incPrivate = *includePrivate
	}

	if after == nil {
		var count int32
		err := r.DB.QueryRow(ctx, "SELECT COUNT(*) FROM studysets WHERE (private = false OR $1 = true)", incPrivate).Scan(&count)
		if err != nil {
			return 0, fmt.Errorf("failed to fetch total studysets: %w", err)
		}
		return count, nil
	}

	afterTime, err := time.Parse(time.RFC3339, *after)
	if err != nil {
		return 0, fmt.Errorf("invalid date format: %w", err)
	}

	var count int32
	err = r.DB.QueryRow(ctx, "SELECT COUNT(*) FROM studysets WHERE (private = false OR $1 = true) AND created_at > $2", incPrivate, afterTime).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to fetch studysets after date: %w", err)
	}
	return count, nil
}

// StudysetUpdateCount is the resolver for the studysetUpdateCount field.
func (r *queryResolver) StudysetUpdateCount(ctx context.Context, after *string, includePrivate *bool) (int32, error) {
	incPrivate := false
	if includePrivate != nil {
		incPrivate = *includePrivate
	}

	if after == nil {
		var count int32
		err := r.DB.QueryRow(ctx, "SELECT COUNT(*) FROM studysets WHERE (private = false OR $1 = true)", incPrivate).Scan(&count)
		if err != nil {
			return 0, fmt.Errorf("failed to fetch total studysets: %w", err)
		}
		return count, nil
	}

	afterTime, err := time.Parse(time.RFC3339, *after)
	if err != nil {
		return 0, fmt.Errorf("invalid date format: %w", err)
	}

	var count int32
	err = r.DB.QueryRow(ctx, "SELECT COUNT(*) FROM studysets WHERE (private = false OR $1 = true) AND updated_at > $2", incPrivate, afterTime).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to fetch studysets updated after date: %w", err)
	}
	return count, nil
}

// Subject is the resolver for the subject field.
func (r *studysetResolver) Subject(ctx context.Context, obj *model.Studyset) (*model.Subject, error) {
	if obj.SubjectID == nil {
		return nil, nil
	}

	var subject model.Subject
	err := pgxscan.Get(
		ctx,
		r.DB,
		&subject,
		`SELECT id, name, category FROM subjects WHERE id = $1`,
		*obj.SubjectID,
	)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get subject from studyset: %w", err)
	}

	return &subject, nil
}

// User is the resolver for the user field.
func (r *studysetResolver) User(ctx context.Context, obj *model.Studyset) (*model.User, error) {
	if obj.UserID == nil {
		return nil, nil
	}

	return loader.GetUser(ctx, *obj.UserID)
}

// Terms is the resolver for the terms field.
func (r *studysetResolver) Terms(ctx context.Context, obj *model.Studyset) ([]*model.Term, error) {
	if obj.ID == nil {
		return nil, nil
	}

	return loader.GetTermsByStudysetID(ctx, *obj.ID)
}

// TermsCount is the resolver for the terms_count field.
func (r *studysetResolver) TermsCount(ctx context.Context, obj *model.Studyset) (*int32, error) {
	if obj.ID == nil {
		return nil, nil
	}

	return loader.GetTermsCountByStudysetID(ctx, *obj.ID)
}

// PracticeTests is the resolver for the practice_tests field.
func (r *studysetResolver) PracticeTests(ctx context.Context, obj *model.Studyset) ([]*model.PracticeTest, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil || authedUser.ID == nil || obj.ID == nil {
		return nil, nil
	}

	return loader.GetPracticeTestsByStudysetID(ctx, *obj.ID)
}

// Saved is the resolver for the saved field.
func (r *studysetResolver) Saved(ctx context.Context, obj *model.Studyset) (*bool, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if obj == nil || obj.ID == nil {
		return nil, nil
	}

	var result bool
	sql := `SELECT EXISTS (
		SELECT 1 FROM saved_studysets WHERE studyset_id = $1 AND user_id = $2
	)`
	err := pgxscan.Get(ctx, r.DB, &result, sql, *obj.ID, authedUser.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to check studyset saved field: %w", err)
	}

	return &result, nil
}

// Folder is the resolver for the folder field.
func (r *studysetResolver) Folder(ctx context.Context, obj *model.Studyset) (*model.Folder, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if obj == nil || obj.ID == nil {
		return nil, nil
	}

	var folder model.Folder
	sql := `
		SELECT f.id, f.name FROM folders f
	    JOIN folder_studysets fs ON fs.folder_id = f.id
	    WHERE fs.studyset_id = $1 AND fs.user_id = $2 AND f.user_id = $2
	`
	err := pgxscan.Get(ctx, r.DB, &folder, sql, *obj.ID, authedUser.ID)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, nil
		}

		return nil, fmt.Errorf("failed to check studyset folder field: %w", err)
	}

	return &folder, nil
}

// Studysets is the resolver for the studysets field.
func (r *subjectResolver) Studysets(ctx context.Context, obj *model.Subject, first *int32, after *string, last *int32, before *string) (*model.StudysetConnection, error) {
	if obj == nil || obj.ID == nil {
		return nil, nil
	}

	l := 24
	if first != nil && *first > 0 && *first < 1000 {
		l = int(*first)
	} else if last != nil && *last > 0 && *last < 1000 {
		l = int(*last)
	}
	limit := l + 1

	cursorTS, cursorID := DecodeStudysetCursor(ptrToString(after))
	beforeCursorTS, beforeCursorID := DecodeStudysetCursor(ptrToString(before))

	isBackward := beforeCursorID != ""
	hasPrevious := false
	if !isBackward {
		hasPrevious = cursorTS != "" || cursorID != ""
	}

	var studysets []*model.Studyset
	var err error
	if isBackward {
		sql := `
			SELECT
				s.id,
				s.user_id,
				s.title,
				s.private,
				s.subject_id,
				to_char(s.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(s.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM studysets s
			JOIN subjects ON s.subject_id = subjects.id
			WHERE subjects.id = $1
				AND s.private = false
				AND (to_char(s.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), s.id) > ($2, $3::uuid)
			ORDER BY s.updated_at ASC, s.id ASC
			LIMIT $4
		`
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, *obj.ID, beforeCursorTS, beforeCursorID, limit)
		if err == nil {
			hasPrevious = len(studysets) > l
			if hasPrevious {
				studysets = studysets[:l]
			}
			// Reverse
			for i, j := 0, len(studysets)-1; i < j; i, j = i+1, j-1 {
				studysets[i], studysets[j] = studysets[j], studysets[i]
			}
		}
	} else if cursorID != "" {
		sql := `
			SELECT
				s.id,
				s.user_id,
				s.title,
				s.private,
				s.subject_id,
				to_char(s.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(s.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM studysets s
			JOIN subjects ON s.subject_id = subjects.id
			WHERE subjects.id = $1
				AND s.private = false
				AND (to_char(s.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM'), s.id) < ($2, $3::uuid)
			ORDER BY s.updated_at DESC, s.id DESC
			LIMIT $4
		`
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, *obj.ID, cursorTS, cursorID, limit)
	} else {
		sql := `
			SELECT
				s.id,
				s.user_id,
				s.title,
				s.private,
				s.subject_id,
				to_char(s.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
				to_char(s.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM studysets s
			JOIN subjects ON s.subject_id = subjects.id
			WHERE subjects.id = $1
				AND s.private = false
			ORDER BY s.updated_at DESC, s.id DESC
			LIMIT $2
		`
		err = pgxscan.Select(ctx, r.DB, &studysets, sql, *obj.ID, limit)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to fetch subject's studysets: %w", err)
	}

	hasNext := false
	if isBackward {
		hasNext = true
	} else {
		hasNext = len(studysets) > l
		if hasNext {
			studysets = studysets[:l]
		}
	}
	getCursor := func(s *model.Studyset) (string, string) {
		return ptrToString(s.UpdatedAt), ptrToString(s.ID)
	}
	return StudysetConnectionFrom(studysets, hasNext, hasPrevious, getCursor), nil
}

// Progress is the resolver for the progress field.
func (r *termResolver) Progress(ctx context.Context, obj *model.Term) (*model.TermProgress, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil || authedUser.ID == nil || obj.ID == nil {
		return nil, nil
	}

	return loader.GetTermProgress(ctx, *obj.ID)
}

// ProgressHistory is the resolver for the progressHistory field.
func (r *termResolver) ProgressHistory(ctx context.Context, obj *model.Term) ([]*model.TermProgressHistory, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil || authedUser.ID == nil || obj.ID == nil {
		return nil, nil
	}

	return loader.GetTermProgressHistory(ctx, *obj.ID)
}

// TopConfusionPairs is the resolver for the top_confusion_pairs field.
func (r *termResolver) TopConfusionPairs(ctx context.Context, obj *model.Term) ([]*model.TermConfusionPair, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil || authedUser.ID == nil || obj.ID == nil {
		return nil, nil
	}

	return loader.GetTermTopConfusionPairs(ctx, *obj.ID)
}

// TopReverseConfusionPairs is the resolver for the top_reverse_confusion_pairs field.
func (r *termResolver) TopReverseConfusionPairs(ctx context.Context, obj *model.Term) ([]*model.TermConfusionPair, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil || authedUser.ID == nil || obj.ID == nil {
		return nil, nil
	}

	return loader.GetTermTopReverseConfusionPairs(ctx, *obj.ID)
}

// Term is the resolver for the term field.
func (r *termConfusionPairResolver) Term(ctx context.Context, obj *model.TermConfusionPair) (*model.Term, error) {
	if obj.TermID == nil {
		return nil, nil
	}

	return loader.GetTermByID(ctx, *obj.TermID)
}

// ConfusedTerm is the resolver for the confusedTerm field.
func (r *termConfusionPairResolver) ConfusedTerm(ctx context.Context, obj *model.TermConfusionPair) (*model.Term, error) {
	if obj.ConfusedTermID == nil {
		return nil, nil
	}

	return loader.GetTermByID(ctx, *obj.ConfusedTermID)
}

// Folder returns FolderResolver implementation.
func (r *Resolver) Folder() FolderResolver { return &folderResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Studyset returns StudysetResolver implementation.
func (r *Resolver) Studyset() StudysetResolver { return &studysetResolver{r} }

// Subject returns SubjectResolver implementation.
func (r *Resolver) Subject() SubjectResolver { return &subjectResolver{r} }

// Term returns TermResolver implementation.
func (r *Resolver) Term() TermResolver { return &termResolver{r} }

// TermConfusionPair returns TermConfusionPairResolver implementation.
func (r *Resolver) TermConfusionPair() TermConfusionPairResolver {
	return &termConfusionPairResolver{r}
}

type folderResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type studysetResolver struct{ *Resolver }
type subjectResolver struct{ *Resolver }
type termResolver struct{ *Resolver }
type termConfusionPairResolver struct{ *Resolver }
