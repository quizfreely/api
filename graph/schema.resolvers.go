package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"quizfreely/api/auth"
	"quizfreely/api/graph/model"
	"strings"

	"github.com/georgysavva/scany/v2/pgxscan"
)

// CreateStudyset is the resolver for the createStudyset field.
func (r *mutationResolver) CreateStudyset(ctx context.Context, studyset model.StudysetInput, terms []*model.NewTermInput) (*model.Studyset, error) {
	panic(fmt.Errorf("not implemented: CreateStudyset - createStudyset"))
}

// UpdateStudyset is the resolver for the updateStudyset field.
func (r *mutationResolver) UpdateStudyset(ctx context.Context, id string, studyset *model.StudysetInput, terms []*model.TermInput) (*model.Studyset, error) {
	panic(fmt.Errorf("not implemented: UpdateStudyset - updateStudyset"))
}

// DeleteStudyset is the resolver for the deleteStudyset field.
func (r *mutationResolver) DeleteStudyset(ctx context.Context, id string) (*string, error) {
	panic(fmt.Errorf("not implemented: DeleteStudyset - deleteStudyset"))
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, displayName *string) (*model.AuthedUser, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if displayName != nil {
		trimmedDisplayName := strings.TrimSpace(*displayName)
		if len(trimmedDisplayName) < 1 || len(trimmedDisplayName) > 32 {
			return nil, fmt.Errorf("display name must be between 1 and 32 characters")
		}
		if *displayName != trimmedDisplayName {
			return nil, fmt.Errorf("display name must not have leading or trailing whitespace")
		}
	} else {
		return authedUser, nil
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var updatedUser model.AuthedUser
	err = pgxscan.Get(ctx, tx, &updatedUser,
		`UPDATE auth.users SET display_name = $1 WHERE id = $2 RETURNING id, display_name`,
		*displayName, authedUser.ID)

	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &updatedUser, nil
}

// UpdateTermProgress is the resolver for the updateTermProgress field.
func (r *mutationResolver) UpdateTermProgress(ctx context.Context, id string, progress model.TermProgressInput) (*model.TermProgress, error) {
	panic(fmt.Errorf("not implemented: UpdateTermProgress - updateTermProgress"))
}

// Authed is the resolver for the authed field.
func (r *queryResolver) Authed(ctx context.Context) (*bool, error) {
	authed := auth.AuthedUserContext(ctx) != nil
	return &authed, nil
}

// AuthedUser is the resolver for the authedUser field.
func (r *queryResolver) AuthedUser(ctx context.Context) (*model.AuthedUser, error) {
	return auth.AuthedUserContext(ctx), nil
}

// Studyset is the resolver for the studyset field.
func (r *queryResolver) Studyset(ctx context.Context, id string) (*model.Studyset, error) {
	panic(fmt.Errorf("not implemented: Studyset - studyset"))
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	var user model.User
	sql := `
		SELECT
			id,
			username,
			display_name,
		FROM auth.users
		WHERE id = $1
	`
	err := pgxscan.Get(ctx, r.DB, &user, sql, id)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}
	return &user, nil
}

// FeaturedStudysets is the resolver for the featuredStudysets field.
func (r *queryResolver) FeaturedStudysets(ctx context.Context, limit *int32, offset *int32) ([]*model.Studyset, error) {
	l := 20
	if limit != nil && *limit > 0 && *limit < 20 {
		l = int(*limit)
	}

	o := 0
	if offset != nil && *offset > 0 {
		o = int(*offset)
	}

	var studysets []*model.Studyset
	sql := `
		SELECT
			id,
			user_id,
			title,
			private,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		FROM public.studysets
		WHERE private = false
			AND featured = true
		ORDER BY terms_count DESC
		LIMIT $1 OFFSET $2
	`
	err := pgxscan.Select(ctx, r.DB, &studysets, sql, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch featured studysets: %w", err)
	}

	return studysets, nil
}

// RecentStudysets is the resolver for the recentStudysets field.
func (r *queryResolver) RecentStudysets(ctx context.Context, limit *int32, offset *int32) ([]*model.Studyset, error) {
	l := 20
	if limit != nil && *limit > 0 && *limit < 20 {
		l = int(*limit)
	}

	o := 0
	if offset != nil && *offset > 0 {
		o = int(*offset)
	}

	var studysets []*model.Studyset
	sql := `
		SELECT
			id,
			user_id,
			title,
			private,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		FROM public.studysets
		WHERE private = false
		ORDER BY updated_at DESC
		LIMIT $1 OFFSET $2
	`
	err := pgxscan.Select(ctx, r.DB, &studysets, sql, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch recent studysets: %w", err)
	}

	return studysets, nil
}

// SearchStudysets is the resolver for the searchStudysets field.
func (r *queryResolver) SearchStudysets(ctx context.Context, q string, limit *int32, offset *int32) ([]*model.Studyset, error) {
	panic(fmt.Errorf("not implemented: SearchStudysets - searchStudysets"))
}

// MyStudysets is the resolver for the myStudysets field.
func (r *queryResolver) MyStudysets(ctx context.Context, limit *int32, offset *int32) ([]*model.Studyset, error) {
	panic(fmt.Errorf("not implemented: MyStudysets - myStudysets"))
}

// User is the resolver for the user field.
func (r *studysetResolver) User(ctx context.Context, obj *model.Studyset) (*model.User, error) {
	if obj.UserID == nil {
		return nil, nil
	}

	var user model.User
	sql := `
		SELECT
			id,
			username,
			display_name
		FROM auth.users
		WHERE id = $1
	`
	err := pgxscan.Get(ctx, r.DB, &user, sql, obj.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user from studyset: %w", err)
	}

	return &user, nil
}

// Terms is the resolver for the terms field.
func (r *studysetResolver) Terms(ctx context.Context, obj *model.Studyset) ([]*model.Term, error) {
	var terms []*model.Term
	sql := `
		SELECT
			id,
			term,
			def,
			to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as created_at,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		FROM terms
		WHERE studyset_id = $1
	`
	err := pgxscan.Select(ctx, r.DB, &terms, sql, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get terms from studyset: %w", err)
	}

	return terms, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Studyset returns StudysetResolver implementation.
func (r *Resolver) Studyset() StudysetResolver { return &studysetResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type studysetResolver struct{ *Resolver }
